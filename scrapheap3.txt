

  # def edit_display_properties
  # end

  # def edit_network_details
  # end

  # def edit_runtime_details
  # end


    # else
    #   if @app_install.update_display_properties
    #     if @app_install.update_app_engine == true
    #       redirect_to app_manager_path, notice: 'Application details were successfully updated.'
    #     else
    #       redirect_to app_manager_path, alert: 'Display properties updated, but application host name and domain name not updated.'
    #     end
    #   else
    #     render :edit_display_properties, alert: 'Application details were not updated.'
    #   end
    # end

  #   if @app_install.created_from_existing_engine == 'true'
  #     if @app_install.save
  #       redirect_to app_manager_path, notice: 'Application details were successfully updated.'
  #     else
  #       render :edit_display_properties, alert: 'Application details were not updated.'
  #     end
  #   else
  #     if app_install.update(app_install_params)
  #       if app_install.update_app_engine == true
  #         redirect_to app_manager_path, notice: 'Application details were successfully updated.'
  #       else
  #         redirect_to app_manager_path, alert: 'Display properties updated, but application host name and domain name not updated.'
  #       end
  #     else
  #       render :edit_display_properties, alert: 'Application details were not updated.'
  #     end
  #   end
  # end

  





  # def destroy
  #   if @app_install
  #   respond_to do |format|
  #     format.html { redirect_to installs_url, notice: 'Install was successfully destroyed.' }
  #     format.json { head :no_content }
  #   end
  # end





# require 'open3'
# include ActionController::Live


# def send_message
#   response.headers['Content-Type'] = 'text/event-stream'
#   10.times {
#     response.stream.write "This is a test Message\n"
#     sleep 1
#   }
#   response.stream.close
# end


#   # def install_progress
#   #   @install_progress = install_log
#   #   render stream: true
#   # end

#   def install_progress



#     response.headers['Content-Type'] = 'text/event-stream'
#     100.times {
#       response.stream.write "hello world\n"
#       sleep 0.1
#     }
#   ensure
#     response.stream.close



#   # response.headers['Content-Type'] = 'text/event-stream'
  
#   # begin
#   #   follow_install_log do |line| 
#   #     response.stream.write line
#   #   end
#   # rescue IOError
#   # ensure
#   #   logger.info("Killing stream")
#   #   response.stream.close
#   # end

#   # render stream: true

#   # response.stream.close



#     # begin
#       # follow_install_log do |line| 
#       #   response.stream.write line
#       # end

#     # rescue IOError

#     # ensure
#     #   logger.info("Killing stream")
#     #   response.stream.close
#     # end



# #     response.headers['Content-Type'] = 'text/event-stream'
# # response.stream.write follow_install_log
#     # begin
#     #   follow_install_log do |line| 
#     #     response.stream.write line
#     #   end
#     # rescue IOError
#     # ensure
#     #   logger.info("Killing stream")
#       response.stream.close
#     # end
#   end

#   def follow_install_log
#     begin
#       stdin, stdout, stderr, wait_thread = Open3.popen3("tail -n 100 LICENSE")
#       stdout.each_line do |line|
#         yield line
#         sleep 0.1
#       end
#     rescue IOError
#     ensure
#       stdin.close; stdout.close; stderr.close
#       Process.kill('HUP', wait_thread[:pid])
#       logger.info("Killing Tail pid: #{wait_thread[:pid]}")
#     end



#   # stdin, stdout, stderr, wait_thread = Open3.popen3("tail LICENSE")
#   # stdout.each_line do |line|
#   #   yield line
#   # end


# # ary = ''

# # File.open("LICENSE", "r") do |f|
# #   f.each_line do |line|
# #     ary += line
# #     sleep 0.1
# #   end
# # end

# # p ary

# # return ary
#   end


#   # def follow_log
#   #   begin
#   #     stdin, stdout, stderr, wait_thread = Open3.popen3("tail -F #{Rails.root.join('log', 'development.log')}")

#   #     stdout.each_line do |line|
#   #       yield line
#   #     end

#   #   rescue IOError

#   #   ensure
#   #     stdin.close
#   #     stdout.close
#   #     stderr.close
#   #     Process.kill('HUP', wait_thread[:pid])
#   #     logger.info("Killing Tail pid: #{wait_thread[:pid]}")
#   #   end
#   # end




